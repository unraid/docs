## Versión 6.9.0 2021-02-27

Resumen de nuevas características

## Múltiples pools

Esta función le permite definir hasta 35 pools nombrados, cada uno con hasta 30 dispositivos de almacenamiento por pool. Los pools se crean y gestionan a través de la página principal.

- Nota: Un disco/pool de caché anterior a la versión 6.9.0 ahora es simplemente un pool llamado "cache". Cuando actualice un servidor que tenga un disco/pool de caché definido, se guardará una copia de seguridad de `config/disk.cfg` en `config/disk.cfg.bak`, y luego las configuraciones de asignación de dispositivos de caché se moverán de `config/disk.cfg` a un nuevo archivo, `config/pools/cache.cfg`. Si más tarde vuelve a una versión anterior a la 6.9.0 del sistema operativo Unraid, perderá sus asignaciones de dispositivos de caché y tendrá que reasignar manualmente los dispositivos a la caché. Siempre y cuando reasigne los dispositivos correctos, los datos deberían permanecer intactos.

Cuando crea una compartición de usuario o edita una existente, puede especificar qué pool debe asociarse con esa compartición. El pool asignado funciona de manera idéntica a la operación actual del pool de caché.

Algo a tener en cuenta: cuando se obtiene una lista de directorios de una
compartición, los volúmenes del disco de matriz Unraid y todos los pools que contienen esa
compartición se fusionan en este orden:

> pool asignado a compartición
>
> disco1
>
> `:`
>
> disco28
>
> todas las *otras* piscinas en
> [strverscmp()](https://man7.org/linux/man-pages/man3/strverscmp.3.html)
> orden.

Un pool de un solo dispositivo puede ser formateado con xfs, btrfs, o (obsoleto) reiserfs. Un pool de múltiples dispositivos solo puede ser formateado con btrfs. Una versión futura incluirá soporte para múltiples pools de "Unraid array", así como otros tipos de pools.

- Nota: Algo más a tener en cuenta: Supongamos que tiene un pool btrfs de 2 dispositivos. Esto será lo que btrfs llama "raid1" y lo que la mayoría de la gente entendería como "discos en espejo". Bueno, esto es mayormente cierto en el sentido de que los mismos datos existen en ambos discos pero no necesariamente al nivel de bloques. Ahora supongamos que crea otro pool, y lo que hace es desafectar uno de los dispositivos del pool btrfs de 2 dispositivos existente y lo asigna a este pool. Ahora tiene x2 pools de un solo dispositivo btrfs. Al iniciar la array, el usuario podría suponer razonablemente que ahora hay x2 pools con exactamente los mismos datos. Sin embargo, **esto no es el caso**. En su lugar, cuando el sistema operativo Unraid detecta que un dispositivo btrfs ha sido eliminado de un pool de múltiples dispositivos existente, al iniciar la array hará un `wipefs` en ese dispositivo para que al montarse no se incluya en el pool antiguo. Esto, por supuesto, borra efectivamente todos los datos en el dispositivo movido.

### Opciones adicionales de balanceo btrfs

Los pools de múltiples dispositivos siguen creándose utilizando el perfil de *raid1* de btrfs por defecto. Si tienes 3 o más dispositivos en un pool, ahora puedes reequilibrar al perfil *raid1c3* (x3 copias de datos en dispositivos separados). Si tienes 4 o más dispositivos, ahora reequilibras a *raid1c4* (x4 copias de datos en dispositivos separados). También modificamos la operación de balance de *raid6* para establecer meta-datos a *raid1c3* (anteriormente era *raid1*).

Sin embargo, hemos notado que al aplicar uno de estos filtros de balance a un volumen completamente vacío, algunos extentos de datos quedan con el perfil anterior. La solución es simplemente ejecutar el mismo balance nuevamente. Consideramos que esto es un error de btrfs y si no se encuentra una solución, añadiremos el segundo balance al código por defecto. Por ahora, se deja como está.

### Alineación de partición SSD 1 MiB

Hemos añadido otro diseño de partición donde el inicio de la partición 1 está alineado en un límite de 1 MiB. Es decir, para dispositivos que presentan sectores de 512 bytes, la partición 1 comenzará en el sector 2048; para dispositivos con sectores de 4096 bytes, en el sector 256. Este tipo de partición ahora se utiliza al formatear todo el almacenamiento no rotacional sin formato (únicamente).

No está claro qué beneficio ofrece la alineación de 1 MiB. Para algunos dispositivos SSD, es posible que no note ninguna diferencia; para otros, quizás una gran diferencia en el rendimiento. LimeTech no recomienda volver a particionar un dispositivo SSD existente a menos que tenga una razón de peso para hacerlo (o que su TOC simplemente no lo permita).

Para volver a particionar un SSD es necesario primero eliminar cualquier estructura de partición existente en el dispositivo. Por supuesto, **esto borrará todos los datos** en el dispositivo. Probablemente la forma más fácil de lograr esto es, con la array detenida, identificar el/los dispositivo(s) a borrar y utilizar el comando 'blkdiscard':

`blkdiscard /dev/xxx  # por ejemplo /dev/sdb o /dev/nvme0n1 etc`

ADVERTENCIA: asegúrate de escribir el identificador de dispositivo correcto porque
**¡todos los datos se perderán en ese dispositivo!**

Al iniciar la matriz, el dispositivo aparecerá como No formateado, y dado
que ahora no hay estructura de partición, Unraid OS la creará.

- Nota: Si desea volver a particionar su disco/pool de caché basado en SSD y preservar los datos, considere publicar en el [Foro de la Comunidad Unraid](https://forums.unraid.net/forum/55-general-support/) para obtener ayuda con su configuración particular. Consulte también [esta publicación](https://forums.unraid.net/bug-reports/prereleases/unraid-os-version-690-beta29-available-r1066/) en el tablero de prereleases.

### Manejo SMART y advertencias de umbral de almacenamiento

Hay un archivo de configuración llamado `config/smart-one.cfg` que almacena información relacionada con SMART, por ejemplo, el tipo de controlador que se pasará a `smartctl` con el fin de obtener información SMART. También se almacenan en ese archivo los umbrales de advertencia de volumen y espacio libre crítico. A partir de esta versión, estos ajustes de configuración se manejan de manera diferente.

En el caso de la configuración de SMART, los ajustes se guardan por el ID del dispositivo en lugar del ID de ranura. Esto nos permite gestionar SMART para dispositivos no asignados. También permite que la configuración de SMART "siga al dispositivo" sin importar en qué ranura esté asignado. Sin embargo, esto implica que debe reconfigurar manualmente la configuración de SMART para todos los dispositivos que difieran del valor predeterminado.

Los ajustes de umbral de advertencia de volumen y espacio crítico se han movido de este archivo de configuración y ahora se guardan en `config/disk.cfg` (para la array de Unraid) y en los archivos de configuración del pool para cada pool. Esto implica que debe reconfigurar manualmente estos ajustes para todos los volúmenes que difieran del valor predeterminado.

Después de la actualización, puede recibir una notificación como: `Aviso [TOWER] - El Disco 1 ha vuelto al nivel de utilización normal`. Como se describió anteriormente, todos los ajustes de configuración de SMART se restablecieron al valor predeterminado. Visite `Configuración -> Configuración de Disco` para revisar los valores predeterminados y anularlos para discos individuales en `Principal -> Disco X -> Configuración`.

## Mejor soporte para módulos/controladores de terceros

Recuerde que distribuimos módulos y firmware de Linux en archivos squashfs separados que se montan en modo de solo lectura en `/lib/modules` y `/lib/firmware`. Ahora configuramos un overlayfs en cada uno de estos puntos de montaje, lo que hace posible instalar módulos de terceros usando el sistema de complementos, siempre que esos módulos estén construidos contra la versión actual del kernel en ejecución. Además, definimos un nuevo directorio en el dispositivo de arranque USB llamado `config/modprobe.d` cuyo contenido se copia a `/etc/modprobe.d` al principio de la secuencia de arranque antes de que el kernel de Linux cargue cualquier módulo.

Esta técnica se utiliza para instalar el controlador Nvidia (ver abajo) y puede
ser utilizada por los desarrolladores de la comunidad para proporcionar un método más sencillo para añadir módulos no incluidos en la base Unraid OS:
no es necesario construir archivos personalizados bzimage,
bzmodules, bzfirmware y, bzroot!

### Pasar parámetros a módulos

El uso de archivos `conf` en `config/modprobe.d` puede usarse para especificar
opciones y pasar argumentos a los módulos.

Como ejemplo: actualmente no contamos con soporte de UI para especificar cuál interfaz de red debería ser "primaria" en un vínculo; el controlador de vinculación simplemente selecciona el primer miembro de forma predeterminada. En algunas configuraciones, puede ser útil especificar una interfaz preferida explícita, por ejemplo, si tiene un vínculo con una interfaz de 1 Gbit/s (eth0) y otra de 10 Gbit/s (eth1).

Dado que configurar el bond implica cargar el módulo kernel de bonding,
y puedes especificar qué interfaz establecer como primaria usando este método:

Crea un archivo en el flash: `config/modprobe.d/bonding.conf` que
contenga esta única línea, y luego reinicia:

`opciones bonding primary=eth1`

Después del reinicio puedes verificar si funcionó escribiendo este comando:

`cat /proc/net/bonding/bond0`

donde deberías ver la interfaz seleccionada como "Esclavo primario".

### Controlador Nvidia

El objetivo de crear superposiciones squashfs montadas en `/lib/modules` y `/lib/firmware`, junto con proporcionar un mecanismo para definir parámetros de módulos personalizados, es proveer una manera de integrar controladores de terceros en Unraid OS sin requerir construcciones personalizadas de los archivos bz\*. Uno de los controladores de terceros más populares solicitados para Unraid OS es el controlador Linux GPU de Nvidia. Este controlador es requerido para la capacidad de transcodificación en contenedores Docker. Proveer este controlador como un complemento para Unraid OS ha requerido mucho trabajo para configurar un entorno de desarrollo, compilar el controlador y herramientas, y luego descomprimir bzmodules, añadir el controlador, crear nuevos bzmodules, y finalmente reemplazar en el directorio raíz del USB flash. Este trabajo ha sido realizado por miembros de la comunidad [@chbmb](https://forums.unraid.net/profile/6219-chbmb/), [@bass\_rock](https://forums.unraid.net/profile/78406-bass_rock/), y otros. Continuando sobre su trabajo, junto con el miembro [@ich777](https://forums.unraid.net/profile/72388-ich777/) ahora creamos paquetes de controladores Nvidia separados construidos contra cada nuevo lanzamiento de Unraid OS que utiliza un nuevo kernel, pero no incluidos directamente en la distribución base bz\*.

Se puede descargar un archivo JSON que describe la(s) versión(es) del controlador soportadas con cada kernel aquí:

[https://s3.amazonaws.com/dnld.lime-technology.com/drivers/releases.json](https://s3.amazonaws.com/dnld.lime-technology.com/drivers/releases.json)

Cada paquete de controladores incluye el controlador GPU Linux de Nvidia junto con un conjunto de herramientas de contenedor. Las herramientas del contenedor incluyen:

`nvidia-container-runtime`\
`nvidia-container-toolkit`\
`libnvidia-container`

Estas herramientas son útiles para facilitar la transcodificación acelerada en contenedores Docker. ¡Un gran agradecimiento! al miembro de la comunidad [@ich777](https://forums.unraid.net/profile/72388-ich777/) por su ayuda y por proporcionar las herramientas. [@ich777](https://forums.unraid.net/profile/72388-ich777/) también ha proporcionado un [complemento práctico](https://raw.githubusercontent.com/ich777/unraid-nvidia-driver/master/nvidia-driver.plg) para facilitar la instalación del controlador correcto.

La inclusión de módulos de terceros en Unraid OS mediante el sistema de complementos aún está en progreso. Por ejemplo, otro candidato sería reemplazar los controladores de red Intel en árbol de Linux con los controladores personalizados de Intel para Linux.

## Docker

Ahora es posible seleccionar diferentes iconos para múltiples contenedores del mismo tipo. Este cambio requiere una nueva descarga de los iconos para todas sus aplicaciones Docker instaladas. Se espera un retraso al cargar inicialmente el Tablero o la pestaña Docker mientras esto sucede, antes de que los contenedores aparezcan.

También realizamos algunos cambios para añadir flexibilidad en la asignación de almacenamiento para el motor Docker. Esto se configura utilizando el ajuste Settings/Docker Settings/Docker data root. Esto le permite seleccionar cómo mantener el estado persistente de Docker (capas de imagen):

- En un vdisk formateado como btrfs montado en bucle en /var/lib/docker. En este caso, el nombre del archivo de imagen debe ser 'docker.img'.
- En un vdisk formateado como xfs montado en bucle en /var/lib/docker. En este caso, el nombre del archivo de imagen debe ser 'docker-xfs.img'.
- En un directorio especificado que está montado en vinculante en /var/lib/docker. Además, el sistema de archivos donde se encuentra este directorio debe ser btrfs o xfs.

Docker usará ya sea el controlador de almacenamiento 'btrfs' en el caso de
vdisk/directorio formateado en btrfs, o el controlador de almacenamiento 'overlay2' en
el caso de vdisk/directorio formateado en xfs.

Implementado como sigue: Primero, `rc.docker` detectará el tipo de sistema de archivos montado en `/var/lib/docker`. Ahora soportamos btrfs o xfs y el controlador de almacenamiento de Docker se establece adecuadamente.

A continuación, se modifica `mount_image` para soportar un archivo de bucle formateado ya sea con btrfs o xfs dependiendo del sufijo del nombre del archivo de bucle. Por ejemplo, si el nombre del archivo termina con `.img`, como en `docker.img`, entonces se usa `mkfs.btrfs`. Si el nombre del archivo termina con `-xfs.img`, como en `docker-xfs.img` entonces se utiliza `mkfs.xfs`.

Además, añadimos la capacidad de montar en vinculante un directorio en lugar de usar un bucle. Si el nombre del archivo no termina con `.img`, entonces el código asume que este es el nombre de un directorio (presumiblemente en una compartición) que está montado en vinculante en `/var/lib/docker`. Por ejemplo, si `/mnt/user/system/docker/docker` entonces primero creamos, si es necesario, el directorio `/mnt/user/system/docker/docker`. Si esta ruta está en una compartición de usuario, entonces "des-referenciamos" la ruta para obtener la ruta del disco que luego se monta en vinculante en `/var/lib/docker`. Por ejemplo, si `/mnt/user/system/docker/docker` está en "disk1", entonces montaríamos en vinculante `/mnt/disk1/system/docker/docker`. Precaución: la compartición debe ser solo-caché o no-caché para que 'mover' no intente mover el directorio, pero el script no verifica esto.

## Virtualización

Hemos integrado cambios en la página de dispositivos del sistema Tools → System Devices realizada por el usuario [@Skitals](https://forums.unraid.net/profile/97624-skitals/) con refinamientos del usuario [@ljm42](https://forums.unraid.net/profile/61877-ljm42/). Ahora puedes seleccionar dispositivos PCI para aislar de Linux al inicio simplemente clickeando algunas casillas. Esto facilita reservar esos dispositivos para ser asignados a las VM. Esta técnica se conoce como *stubbing* (porque se asigna un controlador falso o dummy al dispositivo en el arranque, impidiendo que el controlador real de Linux sea asignado).

Uno podría preguntarse, si podemos *bloquear* controladores individuales, ¿por qué necesitamos hacer stub de esos dispositivos para asignarlos a las VM? La respuesta es: puedes hacerlo. Pero, si tienes múltiples dispositivos del mismo tipo, donde algunos necesitan ser pasados a una VM y algunos necesitan tener instalado el controlador de Linux del host, entonces debes usar stubbing para los dispositivos que pasarán a las VM.

Nota: Si tenía instalado el complemento de Configuración VFIO-PCI, debe eliminarlo, ya que esa funcionalidad ahora está incorporada en Unraid OS 6.9. Si había suprimido manualmente los dispositivos modificando su archivo Syslinux, considere cambiar al nuevo método como se describe en la [guía vfio-pci](https://forums.unraid.net/topic/93781-guide-bind-devices-to-vfio-pci-for-easy-passthrough-to-vms/).

## Soporte multilingüe

Otra emocionante nueva característica en Unraid 6.9 es la habilidad de descargar
paquetes de idiomas y usar el Unraid OS en varios idiomas diferentes.

Una gran cantidad de trabajo y esfuerzo ha sido implementado por [@bonienl](https://forums.unraid.net/profile/2736-bonienl/) para proporcionar soporte multilingüe en la Utilidad de Gestión del OS Unraid, también conocido como WebGUI. Actualmente, *Inglés, Español, Francés, Alemán, Holandés, Árabe, Chino Simplificado, Portugués y Polaco* están disponibles y varios otros están en proceso.

Gracias a [@Squid](https://forums.unraid.net/profile/10290-squid/),
los paquetes de idiomas se instalan a través del plugin de Aplicaciones de la Comunidad - busca una nueva categoría llamada Idiomas.

- Nota: Las Aplicaciones de la Comunidad deben estar actualizadas para instalar idiomas. Para más detalles, [ver aquí.](https://forums.unraid.net/topic/38582-plug-in-community-applications/page/124/?tab=comments#comment-866710)

Cada paquete de idioma existe en los repositorios públicos de github de la organización Unraid. Se anima a los usuarios interesados a clonar y emitir solicitudes de extracción para corregir errores de traducción. Las traducciones de idiomas y la fusión de PR son gestionadas por [@SpencerJ](https://forums.unraid.net/profile/88446-spencerj/).

*Para más información sobre el Soporte Multilingüe, [por favor revisa nuestra guía.](https://unraid.net/blog/unraid-6-9-multi-language-support)*

También hemos añadido una [Sección Multi-Idioma del Foro de la Comunidad de Unraid](https://forums.unraid.net/forum/75-multi-language-section/).

## Otro

### Integración de Controlador GPU

Unraid OS ahora incluye los controladores GPU en árbol seleccionados: ast (Aspeed), i915 (Intel), amdgpu y radeon (AMD). Para mantener la compatibilidad hacia atrás, estos controladores están en lista negra por defecto a través de los archivos `conf` correspondientes en `/etc/modprobe.d`:

`/etc/modprobe.d/ast.conf`\
`/etc/modprobe.d/i915.conf`\
`/etc/modprobe.d/amdgpu.conf`\
`/etc/modprobe.d/radeon.conf`

Cada uno de estos archivos tiene una sola línea que *bloquea* el controlador, impidiendo que sea cargado por el kernel de Linux.

Es posible anular las configuraciones en estos archivos creando un archivo `conf` personalizado en el directorio `config/modprobe.d` en su dispositivo de arranque USB flash. Por ejemplo, para quitar de la lista negra el controlador amdgpu, cree un archivo vacío escribiendo este comando en una sesión de Terminal:

`touch /boot/config/modprobe.d/amdgpu.conf`

Esto solo necesita hacerse una vez, no es necesario añadirlo a tu guion de inicio.

En 6.9.1, si tu guion de inicio contiene un comando modprobe para tu GPU
y/o un comando para corregir los permisos en `/dev/dri`, deberías eliminarlos:

`modprobe amdgpu`\
`chmod -R 777 /dev/dri`

En 6.9.0, si el contenedor de Docker que usas no puede acceder al GPU,
agrega/mantén esta línea en tu guion de inicio:

`chmod -R 777 /dev/dri`

pero remueve esta:

`modprobe amdgpu`

### Núcleo de Linux

Estamos usando el núcleo [LTS](https://www.kernel.org/) (Soporte a Largo Plazo): versión 5.10.x.

Nuevas características habilitadas en el núcleo:

- Módulo WireGuard
- Módulo iScsi Target
- Módulo USB/IP

Se incluyen estos controladores fuera del árbol:

- Soporte para el Controlador Ethernet de 10 Gb QLogic QLGE (desde staging)
- RealTek r8125: versión 9.003.05 (incluido para versiones más nuevas de r8125)
- HighPoint rr272x\_1x: versión v1.10.6-19\_12\_05 (según la solicitud del usuario)

Tenga en cuenta que a medida que actualizamos el núcleo de Linux, si un controlador fuera del árbol
ya no se compila, será omitido.

Estos controladores están **omitidos**:

- Highpoint RocketRaid r750 (no se compila)
- Highpoint RocketRaid rr3740a (no se compila)
- Tehuti Networks tn40xx (no se compila)

Si necesitas uno de estos controladores, por favor crea un Informe de Errores y nosotros pasaremos algún tiempo buscando alternativas. Mejor aún, acose al fabricante del controlador para que *ellos* actualicen sus controladores.

### Paquetes base

Todo actualizado a las últimas versiones. Además, se ha integrado [Linux PAM](https://es.wikipedia.org/wiki/Linux_PAM). Esto nos permitirá instalar paquetes de autenticación de dos factores en una futura versión.

### Control de Giro SAS

También deberíamos poder ahora soportar adecuadamente el encendido/apagado de dispositivos SAS (finalmente) y con la extraordinaria ayuda de [@doron](https://forums.unraid.net/profile/8006-doron/) casi estamos allí. Los dispositivos SAS generalmente están diseñados para entornos empresariales donde el apagado de dispositivos es poco común, y muchos dispositivos tienen un comportamiento inconsistente en torno a esta funcionalidad. Esta versión en sí no incluye manejo de giro de dispositivos SAS incorporado, pero [@doron](https://forums.unraid.net/profile/8006-doron/) está proporcionando un complemento donde seguimos abordando algunos detalles molestos.

### Mejoras en SSH

Hay cambios en `/etc/ssh/sshd_conf` para mejorar la seguridad (gracias a
[@Mihai](https://forums.unraid.net/profile/89549-mihai/) y
[@ljm42](https://forums.unraid.net/profile/61877-ljm42/) por
sus sugerencias):

- solo se permite al usuario root iniciar sesión vía ssh (recuerda: no hay
  usuarios tradicionales en Unraid OS - solo 'root')
- ahora se requiere una contraseña no nula. Para configurar una contraseña, ve a la pestaña Usuarios (o Configuración -> Usuarios, dependiendo de tu configuración), luego elige el usuario "root", escribe una contraseña compleja dos veces y presiona CAMBIAR (no REINICIAR)
- el túnel no-root está desactivado

Además, al actualizar, nos aseguramos de que el directorio `config/ssh/root` exista en el dispositivo de arranque USB; y, hemos configurado un enlace simbólico: `/root/.ssh` a este directorio. Esto significa que cualquier archivo que pueda colocar en `/root/.ssh` será persistente a través de los reinicios.

Así que, si previamente habías añadido comandos a tu guion `go` para copiar
`authorized_keys` y otros archivos a `/root/.ssh`, deberías eliminar
esos comandos y simplemente poner los archivos en `config/ssh/root`, luego
reiniciar.

Nota: si examina el script de inicio sshd `/etc/rc.d/rc.sshd`, al arrancar todos los archivos de el directorio `config/ssh` se copian a `/etc/ssh` (pero no los subdirectorios). El propósito es restaurar las claves ssh del host; sin embargo, este mecanismo puede usarse para definir archivos `ssh_conf` y `sshd_conf` personalizados.

### "errores GSO inesperados"

Si tu registro de sistema está siendo inundado con errores como:

`Feb 20 09:09:21 Tower kernel: tun: tipo GSO inesperado: 0x0, gso_size 31, hdr_len 66`

Necesitas editar cada VM y cambiar el tipo de modelo para el puente Ethernet de `virtio` a `virtio-net`. En la mayoría de los casos esto se puede lograr simplemente haciendo clic en Actualizar en "Vista de Formulario" en la página de Edición de la VM. Para otras configuraciones de red puede ser necesario editar directamente el xml. Ejemplo:

```xml

<interface type='bridge'>
  <mac address='xx:xx:xx:xx:xx:xx'/>
  <source bridge='br0'/>
  <model type='virtio-net'/>
  <address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/>
</interface>
```

### "noVNC encontró un error"

Si recibes un mensaje `noVNC encontró un error` después de actualizar,
por favor limpia la caché de tu navegador.

### El soporte AFP ha sido eliminado

Incluso Apple está [alejándose](https://www.macworld.com/article/3600899/using-afp-to-share-a-mac-drive-its-time-to-change.html)
de este protocolo.

Para la mejor interoperabilidad con macOS, y para exportar una unidad para fines de Time
Machine, por favor asegúrate de que "Configuración/Ajustes SMB/Interoperabilidad mejorada con macOS" esté puesta en "Sí".

## Registro de Cambios

#### Distro base

- aaa\_elflibs: versión 15.0 build 27
- acl: versión 2.2.53
- acpid: versión 2.0.32
- apcupsd: versión 3.14.14
- at-spi2-core: versión 2.36.1
- at: versión 3.2.1
- attr: versión 2.4.48
- avahi: versión 0.8
- bash: versión 5.0.018
- beep: versión 1.3
- bin: versión 11.1
- bluez-firmware: versión 1.2
- bridge-utils: versión 1.7
- brotli: versión 1.0.9 construcción 2
- btrfs-progs: versión 5.10
- bzip2: versión 1.0.8
- ca-certificates: versión 20201219
- celt051: versión 0.5.1.3
- cifs-utils: versión 6.11
- coreutils: versión 8.32
- cpio: versión 2.13
- cpufrequtils: versión 008
- cryptsetup: versión 2.3.4
- curl: versión 7.74.0 (CVE-2020-8231 CVE-2020-8286 CVE-2020-8285
  CVE-2020-8284)
- cyrus-sasl: versión 2.1.27
- db48: versión 4.8.30
- dbus: versión 1.12.20
- dcron: versión 4.5
- devs: versión 2.3.1 construcción 25
- dhcpcd: versión 8.1.9
- diffutils: versión 3.7
- dmidecode: versión 3.3
- dnsmasq: versión 2.84 (CVE-2020-25681 CVE-2020-25682 CVE-2020-25683
  CVE-2020-25684 CVE-2020-25685 CVE-2020-25686 CVE-2020-25687)
- docker: versión 19.03.14
- dosfstools: versión 4.1
- e2fsprogs: versión 1.45.6
- ebtables: versión 2.0.11
- eject: versión 2.1.5
- elvis: versión 2.2\_0
- etc: versión 15.0
- ethtool: versión 5.9
- eudev: versión 3.2.5
- file: versión 5.39
- findutils: versión 4.7.0
- flex: versión 2.6.4
- floppy: versión 5.5
- fontconfig: versión 2.13.92
- freetype: versión 2.10.4
- fribidi: versión 1.0.10
- fuse3: versión 3.10.0
- gawk: versión 4.2.1
- gd: versión 2.2.5
- gdbm: versión 1.18.1
- genpower: versión 1.0.5
- getty-ps: versión 2.1.0b
- git: versión 2.29.1
- glib2: versión 2.66.2
- glibc-solibs: versión 2.30 construcción 2
- glibc-zoneinfo: versión 2020d
- glibc: versión 2.30 construcción 2
- gmp: versión 6.2.0
- gnutls: versión 3.6.15
- gptfdisk: versión 1.0.5
- grep: versión 3.4
- gtk+3: versión 3.24.23
- gzip: versión 1.10
- harfbuzz: versión 2.7.2
- haveged: versión 1.9.13
- hdparm: versión 9.60
- hostname: versión 3.23
- htop: versión 3.0.2
- icu4c: versión 68.1
- inetd: versión 1.79s
- infozip: versión 6.0
- inotify-tools: versión 3.20.2.2
- intel-microcode: versión 20210216
- iproute2: versión 5.9.0
- iptables: versión 1.8.5
- iputils: versión 20200821
- irqbalance: versión 1.6.0
- jansson: versión 2.13.1
- jasper: versión 2.0.22
- jemalloc: versión 5.2.1
- jq: versión 1.6
- kernel-firmware: versión 20210211\_f7915a0
- keyutils: versión 1.6.1
- kmod: versión 27
- krb5: versión 1.18.2
- lbzip2: versión 2.5
- lcms2: versión 2.11
- less: versión 563
- libX11: versión 1.6.12
- libaio: versión 0.3.112
- libarchive: versión 3.4.3
- libcap-ng: versión 0.8 compilación 2
- libcgroup: versión 0.41
- libdaemon: versión 0.14
- libdrm: versión 2.4.102
- libedit: versión 20191231\_3.1
- libestr: versión 0.1.11
- libevdev: versión 1.10.0
- libevent: versión 2.1.12
- libfastjson: versión 0.99.8
- libffi: versión 3.3
- libgcrypt: versión 1.8.7
- libglvnd: versión 1.3.2
- libgpg-error: versión 1.39
- libgudev: versión 234
- libidn: versión 1.36
- libjpeg-turbo: versión 2.0.5
- liblogging: versión 1.0.6
- libmnl: versión 1.0.4
- libnetfilter\_conntrack: versión 1.0.8
- libnfnetlink: versión 1.0.1
- libnftnl: versión 1.1.8
- libnl3: versión 3.5.0
- libpcap: versión 1.9.1
- libpciaccess: versión 0.16
- libpng: versión 1.6.37
- libpsl: versión 0.21.1 compilación 2
- librsvg: versión 2.50.1
- libseccomp: versión 2.4.3
- libssh2: versión 1.9.0
- libssh: versión 0.9.5
- libtasn1: versión 4.16.0
- libtirpc: versión 1.2.6
- libunistring: versión 0.9.10
- libusb-compat: versión 0.1.5
- libusb: versión 1.0.23
- libuv: versión 1.34.0
- libvirt-php: versión 0.5.5
- libvirt: versión 6.6.0 (CVE-2020-14339)
- libwebp: versión 1.1.0 compilación 3
- libwebsockets: versión 3.2.2
- libx86: versión 1.1
- libxkbcommon: versión 1.0.1
- libxml2: versión 2.9.10 compilación 3
- libxslt: versión 1.1.34
- libzip: versión 1.7.3
- lm\_sensors: versión 3.6.0
- lmdb: versión 0.9.27
- logrotate: versión 3.17.0
- lshw: versión B.02.17
- lsof: versión 4.93.2
- lsscsi: versión 0.31
- lvm2: versión 2.03.10
- lz4: versión 1.9.1
- lzip: versión 1.21
- lzo: versión 2.10
- mc: versión 4.8.25
- miniupnpc: versión 2.1
- mpfr: versión 4.1.0
- nano: versión 5.3
- ncompress: versión 4.2.4.6
- ncurses: versión 6.2\_20201024
- net-tools: versión 20181103\_0eebece
- nettle: versión 3.6
- network-scripts: versión 15.0 compilación 9
- nfs-utils: versión 2.1.1
- nghttp2: versión 1.41.0
- nginx: versión 1.19.5 (CVE-2019-9511, CVE-2019-9513, CVE-2019-9516)
- nodejs: versión 13.12.0
- nss-mdns: versión 0.14.1
- ntfs-3g: versión 2017.3.23
- ntp: versión 4.2.8p15 compilación 3
- numactl: versión 2.0.11
- oniguruma: versión 6.9.1
- openldap-client: versión 2.4.49
- openssh: versión 8.4p1 compilación 2
- openssl-solibs: versión 1.1.1i
- openssl: versión 1.1.1i
- p11-kit: versión 0.23.22 (CVE-2020-29361 CVE-2020-29361  CVE-2020-29361)
- pam: versión 1.5.1
- pango: versión 1.46.2
- patch: versión 2.7.6
- pciutils: versión 3.7.0
- pcre2: versión 10.35
- pcre: versión 8.44
- php: versión 7.4.15 (CVE-2019-11048 CVE-2020-7068 CVE-2020-7070  CVE-2020-7069)
- pixman: versión 0.40.0
- pkgtools: versión 15.0 compilación 33
- pm-utils: versión 1.4.1
- procps-ng: versión 3.3.16
- pv: versión 1.6.6
- qemu: versión 5.1.0 (CVE-2020-10717, CVE-2020-10761)
- qrencode: versión 4.0.2
- reiserfsprogs: versión 3.6.27
- rpcbind: versión 1.2.5 compilación 2
- rsync: versión 3.2.3
- rsyslog: versión 8.2002.0
- samba: versión 4.12.11 (CVE-2020-10700, CVE-2020-10704
  CVE-2020-10730, CVE-2020-10745, CVE-2020-10760, CVE-2020-14303
  CVE-2020-1472 CVE-2020-14318 CVE-2020-14318 CVE-2020-14318)
- sdparm: versión 1.11
- sed: versión 4.8
- sg3\_utils: versión 1.45
- shadow: versión 4.8.1
- shared-mime-info: versión 2.0
- smartmontools: versión 7.1
- spice: versión 0.14.1
- sqlite: versión 3.33.0
- ssmtp: versión 2.64
- sudo: versión: 1.9.3p2 (CVE-2021-23239 CVE-2021-23240)
- sysfsutils: versión 2.1.0
- sysvinit-scripts: versión 2.1 compilación 35
- sysvinit: versión 2.97
- talloc: versión 2.3.1 construcción 4
- tar: versión 1.32
- tcp\_wrappers: versión 7.6 build 3
- tdb: versión 1.4.3 compilación 4
- telnet: versión 0.17
- tevent: versión 0.10.2 compilación 4
- traceroute: versión 2.1.0
- tree: versión 1.8.0
- ttyd: versión 20200624
- usbredir: versión 0.7.1
- usbutils: versión 013
- utempter: versión 1.2.0
- util-linux: versión 2.36 compilación 2
- vbetool: versión 1.2.2
- vsftpd: versión 3.0.3 compilación 7
- wget: versión 1.20.3
- which: versión 2.21
- wireguard-tools: versión 1.0.20210223
- wsdd: versión 20180618
- xev: versión 1.2.4
- xf86-video-vesa: versión 2.5.0
- xfsprogs: versión 5.9.0
- xinit: versión 1.4.1
- xkeyboard-config: versión 2.31
- xorg-server: versión 1.20.9 compilación 3
- xterm: versión 361
- xxHash: versión 0.8.0
- xz: versión 5.2.5
- yajl: versión 2.1.0
- zlib: versión 1.2.11
- zstd: versión 1.4.5

#### Núcleo de Linux

- versión 5.10.19
- CONFIG\_WIREGUARD: Túnel de red seguro WireGuard
- CONFIG\_IP\_SET: Soporte de conjunto IP
- CONFIG\_SENSORS\_DRIVETEMP: Unidades de disco duro con sensores de temperatura
- md/Unraid: versión 2.9.17
  - soporte eliminado para spinup group spinup/spdindown (funcionalidad movida a emhttpd)
  - añadido desplazamiento configurable de inicio de sincronización
- se añadió soporte del kernel iSCSI:
   - CONFIG\_ISCSI\_TARGET: Pila de Modo Objetivo de Linux-iSCSI.org
  - CONFIG\_ISCSI\_TARGET\_CXGB4: Controlador de descarga objetivo iSCSI de Chelsio
  - CONFIG\_LOOPBACK\_TARGET: TCM objetivo SAS virtual y módulo de bucle de tejidos LDD Linux/SCSI
  - CONFIG\_NVME\_TARGET: Soporte objetivo NVMe
  - CONFIG\_NVME\_TARGET\_LOOP: Soporte de dispositivo de bucle para NVMe
  - CONFIG\_NVME\_TARGET\_PASSTHRU: Soporte de Passthrough para objetivo NVMe
  - CONFIG\_TARGET\_CORE: Módulo Genérico del Núcleo Objetivo (TCM) e Infraestructura ConfigFS
  - CONFIG\_TCM\_FILEIO: Plugin del Subsistema TCM/FILEIO para Linux/VFS
  - CONFIG\_TCM\_IBLOCK: Plugin del Subsistema TCM/IBLOCK para Linux/BLOCK
  - CONFIG\_TCM\_PSCSI: Plugin del Subsistema TCM/pSCSI para Linux/SCSI
  - CONFIG\_TCM\_USER2: Plugin del Subsistema TCM/USER para Linux
- se añadió soporte del kernel USB/IP:
   - CONFIG\_USBIP\_CORE: Soporte USB/IP
   - CONFIG\_USBIP\_VHCI\_HCD: VHCI hcd
- mpt3sas: se añadió /etc/modprobe.d/mpt3sas-workaround.conf para establecer "max\_queue\_depth=10000"
- oot: Realtek r8152: versión 2.13.0
- oot: Tehuti tn40xx: versión 0.3.6.17.3
- controladores nativos hwmon adicionales habilitados
- controladores hyperv adicionales habilitados

#### Gestión

- Soporte AFP eliminado
- Soporte de Multi-idioma añadido
- Soporte para múltiples pools añadido
- at: suprimir mensajes de syslog de apertura/cierre de sesión
- evitar enviar spinup/spindown a dispositivos no rotacionales
- btrfs: incluir opción de montaje 'discard=async'
- corrección de error: renombrar /etc/krb.conf a /etc/krb5.conf
- limpieza de passwd, shadow
- dhcpcd: ipv6: usar slaac hwaddr en lugar de slaac private
- docker: corregir lógica de asignación del controlador de almacenamiento
- docker: soporte a sistemas de archivos de respaldo btrfs y xfs
- emhtppd: dispositivo cifrado wipefs eliminado del pool de múltiples dispositivos
- emhtptd: rastrear apagado limpio/no limpio usando archivo 'config/forcesync'
- emhttpd: función wipefs añadida (botón 'Erase' en WebGUI)
- emhttpd: evitar eliminación innecesaria del archivo mover.cron
- emhttpd: evitar el uso de remount para establecer opciones de montaje adicionales
- emhttpd: corrección de error: No Smartdata para tipo de controlador no estándar
- emhttpd: corrección de error: no se muestran las temperaturas iniciales de los dispositivos
- emhttpd: corregir lógica 'Erase' para dispositivos de la matriz Unraid
- emhttpd: habilitar SMART en dispositivos al inicio
- emhttpd: corregir la configuración 'auto' donde pools habilitados para shares de usuario
  no deberían exportarse
- emhttpd: corregir que el tipo de controlador SMART del disco no se respeta al leer temperaturas
- emhttpd: corregir que 'smartctl -n standby' externo cause spinup del dispositivo
- emhttpd: eliminar evento poll\_attributes
- emhttpd: implementar spinup/spindown de grupo; agregar llamadas a spinup/spindown
- emhttpd: permitir el borrado de dispositivos de reemplazo 'DISK\_DSBL\_NEW'
- emhttpd: restaurar el llamado al evento 'poll\_attributes'
- emhttpd: dispositivos no asignados se apagan según el predeterminado global
- emhttpd: método de cálculo 'free/used' de btrfs otra vez
- corregir bloqueo de emhttpd.resultante de exportar compartición de disco NFS
- corregir que las particiones de dispositivos no rotacionales no estaban alineadas a 1MiB
- eliminar soporte de plugin 'system' (nunca usado)
- integrar PAM
- integrar cambios de script vfio-pci de ljm42
- loopbacks: permitir xfs o btrfs basado en el nombre de archivo
- modprobe: lista negra de controladores GPU por defecto, config/modprobe.d/\* puede anular al inicio
- montar todos los volúmenes btrfs utilizando la opción 'space\_cache=v2'
- montar loopbacks con la opción 'noatime'; habilitar 'direct-io'
- mount\_image: soportar bind-mount
- particiones de dispositivos no rotacionales alineadas a 1MiB por defecto
- plugin: soporte para validación de archivos sha256
- rsyslog: corregir "Mirror syslog to flash" roto
- samba: desactivar aio por defecto
- shfs: mover: preservar ioctl\_iflags al mover entre los mismos tipos de sistemas de archivos
- shfs: mover: soporte para archivos sparses
- smart-one.cfg mantiene información SMART por ID en lugar de por ranura; configuración de advertencia/ crítico de disco
  movida a cfg de disco/pool
- smb: corregido problema de unión Ad
- smb: eliminar configuración 'aio' en smb.conf, usar valores por defecto de samba
- ssh: añadir enlace simbólico /root/.ssh a directorio /boot/config/ssh/root
- ssh: permitir solo usuario root, requerir contraseñas, deshabilitar túnel no root
- ssh: requerir contraseñas, deshabilitar túnel no root
- inicio: configurar un overlayfs para /lib/modules y /lib/firmware
- syslog: configurar para también escuchar en puerto udp localhost 514
- terminal web: inhibir advertencia emergente al cerrar ventana
- soporte WireGuard: rc.wireguard: añadir reglas iptables
- WebGUI: corregir advertencias de dockerupdate.php
- WebGUI: actualizar statuscheck
- WebGUI: añadir opción de mapa de teclas 'Portuguese (pt)' para libvirt
- WebGUI: añadir tiempo de espera personalizable al detener contenedores
- WebGUI: añadir visor de registros para vfio-pci
- WebGUI: añadir agente de notificación para Discord
- WebGUI: añadir información de pools a diagnósticos
- WebGUI: añadir opciones de balance raid1c3 y raid1c4 para pool btrfs.
- WebGUI: añadir diálogo de actualización en el menú contextual de docker
- WebGUI: opción de reinicio de "modo seguro" de una sola vez añadida
- WebGUI: añadida información btrfs para todos los pools en diagnósticos
- WebGUI: añadida nueva configuración de visualización: mostrar identificadores de dispositivos normalizados o crudos
- WebGUI: añadida nueva configuración "Habilitar asignación de share de usuario" a pool de cache
- WebGUI: añadido soporte para registros docker privados con auth básica
  o sin auth, e mejoras para autenticación basada en token
- WebGUI: permitir diferentes tipos de imagen para cargar con un máximo de 512K
- WebGUI: permitir contenedores duplicados con íconos diferentes
- WebGUI: permitir markdown dentro de descripciones de contenedores
- WebGUI: cambiar ícono para información de placa madre de engranaje (configuración) a info
- WebGUI: cambiado: Consistencia entre el dashboard y docker al acceder a registros
- WebGUI: Dashboard: corregir estadísticas de interfaz faltante
- WebGUI: Dashboard: ajuste de estilo para ícono de servidor
- WebGUI: detectar sesión inválida y cerrar sesión en la pestaña actual
- WebGUI: Diagnósticos: Eliminar Hashes SHA256
- WebGUI: no permitir "?" en nombres de share
- WebGUI: Configuración de pantalla: los colores deberían ser dígitos hexadecimales de 3 o 6 caracteres
- WebGUI: No mostrar perfiles CA en la lista de Añadir Contenedor
- WebGUI: Docker: permitir vdisk BTRFS o XFS, o ubicación de carpeta
- WebGUI: Docker: manejo más intuitivo de imágenes
- WebGUI: corregir aparición de "
- WebGUI: corregir cortes en cambio de idioma Azure / Gris
- WebGUI: corregir advertencias de Banner no descartadas sin recargar la página
- WebGUI: corregir que las VMs iniciadas no aparecen en el dashboard
- WebGUI: corregir bloqueo al leer archivos de registro muy grandes (limitando salida a 1000 líneas).
- WebGUI: corregir descartar todas las notificaciones
- WebGUI: corregir no poder cambiar el horario de verificación de paridad si no hay un pool de cache presente
- WebGUI: corregir notificaciones que reaparecen continuamente
- WebGUI: corregir no puedo usar íconos de la esquina superior derecha si hay notificaciones presentes
- WebGUI: corregir referencia URL errónea de docker run
- WebGUI: corregir: Desplazamiento de Dashboard / Docker en dispositivos iPad
- WebGUI: corregir: establecer correctamente cookie samesite (corregir problema de inicio de sesión con Safari)
- WebGUI: para perfil de datos de pool btrfs raid6 usar perfil de metadata raid1c3.
- WebGUI: reordenamiento de botones de ícono
- WebGUI: página principal: ocultar botón de Mover cuando los shares de usuario no están habilitados
- WebGUI: Multi-idioma: Error de regresión corregido: indicador de campos obligatorios faltante
- WebGUI: Multi-idioma: Corregir no poder eliminar / editar usuarios
- WebGUI: Configuración de red: mostrar el primer servidor DNSv6
- WebGUI: Red: permitir valor de métrica de cero para establecer sin gateway predeterminado
- WebGUI: Red: corregir extensiones de privacidad no establecidas
- WebGUI: Nuevos Perms: Soporte para pools multi-cache
- WebGUI: Notificaciones: Solucionar hueco en blanco / negro
- WebGUI: Permitir configuración de sistema de archivos cuando la matriz esté iniciada para volúmenes no montables.
- WebGUI: Prevenir que "Añadir" vuelva a inglés al agregar un nuevo usuario con un nombre de usuario no válido
- WebGUI: Prevenir que nics enlazados se vinculen demasiado a vfio-pci
- WebGUI: Eliminar WG de Dashboard si no hay túneles definidos
- WebGUI: Mostrar mensaje cuando hay demasiados archivos para explorar
- WebGUI: Soporte de enlaces en notificaciones
- WebGUI: Suprimir enlace de Autofan en Dashboard si el plugin no está instalado
- WebGUI: Suprimir WG en Dashboard si no hay túneles definidos
- WebGUI: Cambiar Diagnósticos a socket web
- WebGUI: SysDevs - advertir si se deja la página sin guardar
- WebGUI: renovación de SysDevs con vinculación vfio-pci.cfg
- WebGUI: ventana de selección de caso tabulada
- WebGUI: Plugins de Tareas: Proveer Capacidad para definir Nombre\_De\_Visualización
- WebGUI: Actualizar Feedback.php
- WebGUI: Actualizar jGrowl a la versión 1.4.7
- WebGUI: Actualizar noVNC a v1.2.0
- WebGUI: Iconos de caso actualizados
- WebGUI: Usar diálogo de actualización de imagen para la entrada de actualización en el menú contextual de docker
- WebGUI: VM Manager: añadir 'virtio-win-0.1.189-1' a la lista de VirtIO-ISOs
- WebGUI: VM manager: corregir: cambiar de gráficos VM VNC a paso a través de GPU
- WebGUI: VM manager: añadir virtio-win-0.1.190-1
- WebGUI: VM manager: nueva configuración "Modelo de Red"
- WebGUI: VMs: corregido: añadir NICs o montajes VirtFS a una VM está limitado
- WebGUI: VMs: corregido: en casos raros vdisk predetermina a Auto cuando debería ser Manual
- WebGUI: VMs: cambiar modelo de red por defecto a virtio-net
- WebGUI: VMs: manejo más intuitivo de la selección de imágenes
- WebGUI: evitar error de sintaxis php si el archivo fuente autov() no existe
- WebGUI: mejor manejo de múltiples nics con vfio-pci
- WebGUI: corregir ícono predeterminado del caso incorrecto en el formulario de inicio de sesión
- WebGUI: no intentar mostrar información SMART que cause spin-up para dispositivos que están apagados
- WebGUI: dockerMan: Permitir leer más en vista avanzada
- WebGUI: dockerMan: Solo permitir nombre compatible con docker
- WebGUI: dockerMan: Comienzo seleccionable al instalar
- WebGUI: corregir: jGrowl cubriendo botones
- WebGUI: corregir: mensaje de inicio de sesión al cambiar entre servidores
- WebGUI: otras mejoras misceláneas
- WebGUI: los pools no habilitados para las comparticiones de usuario no deben ser seleccionables para caché
- WebGUI: sanear entrada en tail\_log
- WebGUI: establecer ícono predeterminado de caso 'mid-tower'
- WebGUI: admitir el encendido/apagado y el monitoreo de temperatura de dispositivos no asignados
- WebGUI: desactivar el autocompletado de nombres de usuario en el formulario de inicio de sesión
- WebGUI: vm manager: preservar la configuración de puertos VNC
- WebGUI: vnc: añadir purga de caché del navegador

["WireGuard" y el logo "WireGuard" son marcas registradas de Jason A. Donenfeld.](https://www.wireguard.com/)
